---
name: Malware Triage
description: Initial malware analysis — file identification, static analysis, string extraction, hash reputation lookup, and suspicious file characterisation for defensive triage.
instructions: |
  Use this skill when the user needs to perform initial triage on a suspicious file, identify
  unknown binaries, extract indicators of compromise, or assess whether a file is potentially
  malicious. This is for defensive analysis only — never assist with creating, improving, or
  weaponising malware. Always show commands before executing them and explain findings in context.
---

# Malware Triage Skill

## Related Commands
- `/mal-file-id` — Identify a suspicious file's type, metadata, and characteristics
- `/mal-strings-analysis` — Extract and analyse strings from a suspicious file
- `/mal-hash-lookup` — Compute file hashes for threat intelligence lookups
- `/mal-static-analysis` — Perform basic static analysis on a binary

## Basic Static Analysis Workflow

When triaging a suspicious file, follow this order:

1. **File identification** — Determine the true file type (magic bytes, not extension)
2. **Metadata collection** — File size, timestamps, permissions
3. **Hash computation** — MD5, SHA-1, SHA-256 for reputation lookups
4. **String extraction** — Look for URLs, IPs, commands, API names
5. **Header analysis** — PE/ELF/Mach-O structure inspection
6. **Packer detection** — Check for UPX or other obfuscation
7. **Reputation lookup** — Check hashes against threat intelligence
8. **Decision** — Safe to analyse further, or escalate to sandbox/IR team

> **Important:** Static analysis should be performed in an isolated environment whenever possible. Never execute a suspicious file on a production system.

## File Type Identification

### Using the `file` command

```bash
file /path/to/suspicious-file
```

The `file` command reads magic bytes (the first few bytes of a file) to determine its true type, regardless of the file extension.

### Inspecting magic bytes directly

```bash
xxd /path/to/suspicious-file | head -4
```

### Common Magic Bytes

| Magic Bytes (hex) | File Type |
|--------------------|-----------|
| `4D 5A` | PE executable (MZ header) — Windows EXE/DLL |
| `7F 45 4C 46` | ELF binary — Linux executable |
| `CF FA ED FE` / `CE FA ED FE` | Mach-O binary — macOS executable |
| `50 4B 03 04` | ZIP archive (also DOCX, XLSX, PPTX, JAR, APK) |
| `25 50 44 46` | PDF document |
| `D0 CF 11 E0` | OLE2 Compound Document (DOC, XLS, PPT) |
| `52 61 72 21` | RAR archive |
| `1F 8B` | Gzip compressed |
| `23 21` | Script (shebang `#!`) |
| `FF D8 FF` | JPEG image |
| `89 50 4E 47` | PNG image |

## String Extraction and Analysis

### Basic string extraction

```bash
# ASCII strings (minimum 4 characters)
strings /path/to/suspicious-file

# Longer strings only (reduces noise)
strings -n 10 /path/to/suspicious-file

# Unicode (UTF-16LE) strings — common in Windows binaries
strings -e l /path/to/suspicious-file
```

### What to look for in strings

```bash
# URLs and domains
strings /path/to/file | grep -oE 'https?://[^ ]+'
strings /path/to/file | grep -oE '[a-zA-Z0-9.-]+\.(com|net|org|io|ru|cn|tk|xyz|top|pw|cc)'

# IP addresses
strings /path/to/file | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'

# Email addresses
strings /path/to/file | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'

# File paths (Windows)
strings /path/to/file | grep -iE '[A-Z]:\\[^ ]+'

# File paths (Unix)
strings /path/to/file | grep -E '^/(tmp|var|etc|home|usr|bin|dev)/[^ ]+'

# Registry keys (Windows malware)
strings /path/to/file | grep -iE 'HKEY_|HKLM|HKCU|SOFTWARE\\|CurrentVersion\\Run'

# Base64-encoded blobs
strings /path/to/file | grep -oE '[A-Za-z0-9+/]{40,}={0,2}'

# Suspicious Windows API names
strings /path/to/file | grep -iE '(VirtualAlloc|CreateRemoteThread|WriteProcessMemory|LoadLibrary|GetProcAddress|WinExec|ShellExecute|URLDownloadToFile|InternetOpen|CreateService|RegSetValue)'
```

### FLOSS (FLARE Obfuscated String Solver)

For obfuscated strings that the standard `strings` command cannot extract, the FLOSS tool (by Mandiant/FireEye) can decode:
- Stack strings (constructed character by character)
- Decoded strings (XOR, Base64, custom encoding)
- Tight strings (short encoded strings)

```bash
# If FLOSS is installed
floss /path/to/suspicious-file
```

> Note: FLOSS is a third-party tool and may not be installed by default. It runs on PE files and is available from https://github.com/mandiant/flare-floss.

## Hash Computation for Reputation Lookup

```bash
# Compute all three standard hashes
md5 /path/to/file 2>/dev/null || md5sum /path/to/file
shasum -a 1 /path/to/file
shasum -a 256 /path/to/file
```

### VirusTotal Hash Lookup

You can look up file hashes on VirusTotal without submitting the file itself. This only queries existing scan results:

```bash
# Using the VirusTotal API (requires API key)
VT_API_KEY="<your-api-key>"
SHA256=$(shasum -a 256 /path/to/file | awk '{print $1}')
curl -s -H "x-apikey: $VT_API_KEY" \
  "https://www.virustotal.com/api/v3/files/$SHA256" | \
  python3 -m json.tool
```

You can also manually search hashes at: `https://www.virustotal.com/gui/search/<hash>`

> **Important:** Looking up a hash does not upload the file. Only use the hash lookup to avoid disclosing sensitive files to third parties.

## PE Header Analysis (Windows Executables)

For PE files analysed on Linux/macOS, use `objdump` or specialised tools:

```bash
# If objdump is available
objdump -x /path/to/file | head -50

# Python pefile (if installed)
python3 -c "import pefile; pe = pefile.PE('/path/to/file'); print(pe.dump_info())"
```

## ELF Header Analysis (Linux Binaries)

```bash
# ELF header
readelf -h /path/to/suspicious-file

# Dynamic section (linked shared libraries)
readelf -d /path/to/suspicious-file

# Section headers (look for unusual sections)
readelf -S /path/to/suspicious-file

# Symbol table
readelf -s /path/to/suspicious-file

# Check if stripped
file /path/to/suspicious-file    # "stripped" = symbols removed (common in malware)
```

## Mach-O Analysis (macOS Binaries)

```bash
# Mach-O header
otool -h /path/to/suspicious-file

# Linked libraries
otool -L /path/to/suspicious-file

# Load commands
otool -l /path/to/suspicious-file

# Code signing information
codesign -dvvv /path/to/suspicious-file 2>&1

# Check if ad-hoc signed or unsigned
codesign -v /path/to/suspicious-file 2>&1
```

## Packer Detection

Packed binaries are compressed or encrypted executables that decompress themselves at runtime. Packing is used legitimately (to reduce file size) but is also common in malware (to evade signature detection).

### UPX Detection

```bash
# Check for UPX signatures in strings
strings /path/to/file | grep -i 'UPX'

# Check section names for UPX markers
readelf -S /path/to/file 2>/dev/null | grep -i 'upx'

# If UPX is installed, attempt to decompress (for analysis only)
upx -t /path/to/file          # Test if UPX-packed
upx -d /path/to/file -o /tmp/unpacked   # Decompress
```

### General Packing Indicators

- **High entropy** in code sections (> 7.0 on a 0-8 scale suggests compression/encryption)
- **Very few readable strings** relative to file size
- **Small import table** — packed binaries often only import `LoadLibrary` and `GetProcAddress`
- **Section names** like `UPX0`, `UPX1`, `.packed`, `.aspack`, `.themida`
- **Entry point** in an unusual section (not `.text`)
- **Large difference** between on-disk size and virtual size of sections

### Entropy Check

```bash
# Quick entropy estimate using ent (if installed)
ent /path/to/suspicious-file

# Python-based entropy calculation
python3 -c "
import math, sys
data = open(sys.argv[1], 'rb').read()
if not data:
    print('Empty file')
    sys.exit(0)
freq = [0]*256
for b in data: freq[b] += 1
entropy = -sum((f/len(data)) * math.log2(f/len(data)) for f in freq if f > 0)
print(f'Entropy: {entropy:.4f} bits/byte (max 8.0)')
if entropy > 7.0:
    print('HIGH entropy — likely packed, compressed, or encrypted')
elif entropy > 6.0:
    print('MODERATE entropy — possibly compressed sections')
else:
    print('LOW entropy — likely not packed')
" /path/to/suspicious-file
```

## Document Macro Indicators

Office documents with malicious macros are a common attack vector.

### OLE2 Documents (DOC, XLS, PPT)

```bash
# Check for OLE2 magic bytes
xxd /path/to/file | head -1    # Look for D0 CF 11 E0

# If olevba is installed (from oletools)
olevba /path/to/document.doc

# If oleid is installed
oleid /path/to/document.doc

# Search for VBA macro indicators in strings
strings /path/to/file | grep -iE '(AutoOpen|AutoExec|Document_Open|Workbook_Open|Auto_Open|Shell|WScript|PowerShell|CreateObject|GetObject|Environ|CallByName)'
```

### OOXML Documents (DOCX, XLSX, PPTX)

OOXML files are ZIP archives — inspect their contents:

```bash
# List contents of the archive
unzip -l /path/to/document.docx

# Look for macro-enabled indicators
unzip -l /path/to/document.docx | grep -iE '(vbaProject|macro)'

# Extract and inspect VBA project
unzip -p /path/to/document.docx word/vbaProject.bin | strings
```

### PDF Macro/Script Indicators

```bash
# Look for JavaScript or action triggers in PDFs
strings /path/to/document.pdf | grep -iE '(/JavaScript|/JS|/Launch|/OpenAction|/AA|/EmbeddedFile|/URI|eval\(|unescape\()'
```

## Suspicious File Characteristics

### Double Extensions

Files like `invoice.pdf.exe` or `report.doc.scr` use double extensions to trick users:

```bash
# Check for double extensions
basename /path/to/file | grep -E '\.[a-zA-Z0-9]+\.[a-zA-Z0-9]+$'
```

### Hidden Characters

Right-to-Left Override (RLE) Unicode characters can reverse part of a filename to hide the true extension (e.g., `report[RLO]fdp.exe` appears as `reportexe.pdf`):

```bash
# Check for Unicode control characters in filename
echo -n "filename" | xxd | grep -E '(e2 80 ae|e2 80 ab|e2 80 8f|e2 80 8e)'
```

### Unusual File Sizes

- Very small executables (< 10 KB) may be droppers or shellcode loaders
- Very large files may contain padding to evade sandbox analysis (some sandboxes skip large files)
- Files that are exactly a power of 2 in size may be raw memory dumps or disk images

```bash
# Check file size
stat -f "%z bytes" /path/to/file 2>/dev/null || stat -c "%s bytes" /path/to/file
ls -la /path/to/file
```

## Sandbox Preparation Guidance

Before executing a suspicious file for dynamic analysis:

1. **Use an isolated VM** — Snapshot before execution, revert after
2. **Disable network access** or route through a monitoring proxy (e.g., INetSim, FakeDNS)
3. **Disable shared folders** between host and guest
4. **Take a baseline** — Process list, network connections, file system state
5. **Monitor during execution** — Process Monitor (Windows), `dtrace`/`fs_usage` (macOS), `strace`/`sysdig` (Linux)
6. **Capture network traffic** — `tcpdump` or Wireshark
7. **Compare after execution** — New processes, files, registry keys, network connections

> **Never execute suspicious files on production systems or systems containing sensitive data.**

## Quick Triage Decision Matrix

| Finding | Risk Level | Action |
|---------|-----------|--------|
| Known malicious hash (VT > 5 detections) | **High** | Quarantine, escalate to IR |
| Unknown hash, high entropy, packed | **Medium-High** | Sandbox analysis required |
| Unknown hash, suspicious strings (C2 URLs, shell commands) | **Medium-High** | Sandbox analysis required |
| Unknown hash, normal entropy, benign strings | **Low-Medium** | Further static analysis, consider sandbox |
| Known clean hash (VT 0 detections, seen widely) | **Low** | Likely safe, verify context |
| Office document with VBA macros from untrusted source | **Medium-High** | Analyse macros before opening |
| PDF with JavaScript or /Launch actions | **Medium** | Analyse in isolated viewer |
